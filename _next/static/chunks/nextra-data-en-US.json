{"/":{"title":"Mongur","data":{"":"Define MongoDB models and query data using Typescript/ES6 classes.Note: It needs a lot more tests before it's ready for use in production.","documentation#Documentation":"https://mongur.dev","install#Install":"# npm\nnpm install mongur --save\n\n# yarn\nyarn add mongur\n\n# pnpm\npnpm add mongur","guides#Guides":"Define your models\nWrite queries\nAPI reference","basic-usage#Basic Usage":"Define your models:\nimport {model, Model} from \"mongur\"\n\n@model()\nexport class User extends Model<User>() {\n\n@field()\nfirstName!: string;\n\n@field()\nlastName!: string;\n\n@field()\nemail!: string\n\n@field()\npassword?: string\n\n}\nConnect:\nimport {connection, MongoClient} from \"mongur\";\n\nconnection.client = new MongoClient(\"mongodb://127.0.0.1:27017/mongur\", {monitorCommands: true})\nawait connetion.connect()\n\nInsert:\nconst user = new User({firstName: \"John\", lastName: \"Doe\", email: \"john@example.com\"})\nawait user.save()\nQuery:\nconst user = await User.find({email: \"john@example.com\"}).one()\nUpdate:\nawait User.find({email: \"john@example.com\"}).update({$set: {email: \"john@example.net\"}})\nDelete:\nawait User.find({email: \"john@example.com\"}).delete()","motivation#Motivation":"// Mongoose example\nconst User = model<IUser>('User', userSchema);\n// Typegoose example\nconst User = getModelForClass(ModelClass);\nHere, in both cases User is not a type, it's a value. Therefore, it cannot be used to specify type in the code.\nFor example, you cannot define a function like this:\n\nfunction doSomething(user: User) { // Error, 'User' refers to a value, but is being used as a type here\n\n}\nMany people counter this problem by writing an interface with the same fields (Declaration Merging). Others just\nuse any type instead. Mongur solves this problem by defining schema using pure class and using the same class for\nquerying data."}},"/models":{"title":"Models","data":{"":"In Mongur, models are created by extending Model and using a decorator called model on the class. All the fields that\nwill be saved in the database need to be decorated with the field decorator.","a-basic-model#A basic model":"import {model, Model, field} from \"mongur\";\n\n\n@model()\nclass User extends Model<User>() {\n\n@field()\nfirstName!: string;\n\n@field()\nlastName!: string;\n\n@field()\nemail!: string;\n\n@field()\npassword?: string\n\n}\nLearn more about @model and @field.\nNote the parentheses in ModelUser>(). The base class is actually returned from a function call.","embedded-documents#Embedded documents":"A model can be embedded in another model in the same way as any other fields except that its type must be specified\nin the @field decorator using the type property.\n@field({type: Publisher})\nIf it's an array, the type needs to be specified as an array like this:\n@field({type: [Author]})\nHere's a complete example:\n\nimport {model, Model, field} from \"mongur\";\n\n// An embedded document model\n\n@model\nclass Publisher extends Model<Publisher> {\n@field()\nname?: string\n\n@field()\nlogo?: string\n}\n\n// Another embedded document model\n\n@model\nclass Author extends Model<Author>{\n@field()\nname?: string\n\n@field()\nphoto?: string\n}\n\n// Main model\n\n@model\nclass Book extends Model<Book>(){\n\n@field()\ntitle!: string;\n\n@field()\nprice!: number;\n\n@field({type: [Author]})\nauthors?: Author[]\n\n@field({type: Publisher})\npublisher?: Publisher\n\n}\nSometimes, you may not want to have an _id field with the sub documents. In that you can specify that in the @field decorator.\n@field({type: Publisher, _id: false})\npublisher?: Publisher\nSee all the available options in @field.","reference-another-model#Reference another model":"Referencing another model is similar to how embedding a model works except that the typescript type of the\nfield need to be specified with Ref. The type property in @field decorator needs to be specified too just like before.\nimport {model, Model, field, Ref} from \"mongur\";\n\n@model\nclass BlogPost extends Model<BlogPost>(){\n\n@field()\ntitle!: string;\n\n@field()\nbody!: string;\n\n@field({type: User})\nauthor!: Ref<User>;\n\n}","use-a-non-model-class-as-the-field-type#Use a non-model class as the field type":"You can create a custom type by extending Factory and implementing 2 methods:\nparse\nimport {field, model, Model, Factory} from \"mongur\";\n\n// Our non-model class\nexport class LatLng {\nconstructor(public readonly lat: number, public readonly lng: number) {\n}\n}\n\n// A factory class to transform the data to and from db and object\nclass LatLngFactory extends Factory<any, LatLng> {\n\n// Parse value saved in the db, to the actual type\nparse(input: any): LatLng {\nreturn new LatLng(input[\"lat\"], input[\"lng\"])\n}\n\n// Covert object instance to the intended format to save in the db\nvalue(input: LatLng): any {\nreturn {\nlat: input.lat,\nlng: input.lat\n}\n}\n}\n\n// Actual model\n@model()\nexport class City extends Model<City>() {\n\n@field()\nname!: string\n\n@field({type: LatLngFactory})\ncenter?: LatLng\n\n}","extending-from-a-common-base-class#Extending from a common base class":"import {model, Model, field} from \"mongur\";\n\n// Write your base class\nclass BaseModel {\n\n@field()\ncreatedAt!: Date;\n\n@field()\nupdatedAt!: Date;\n\n}\n\n// Write the actual model\n@model\nclass Post extends Model<Post & BaseModel>(BaseModel){\n\n@field()\ntitle!: string;\n\n@field()\nbody!: string;\n\n}\n\ninterface Post extends BaseModel {}\n\nHere, Post & BaseModel is for definition. BaseModel next to it, in parentheses, actually does the work of extending.\nFinally, interface User extends BaseModel {} is also for type definition. This is the only weird thing about this library (Promise!)."}},"/queries":{"title":"Queries","data":{"":"Mongur provides a fluent API to query/update/delete data on Mongodb.Let's consider the following model.\n\nimport {model, Model, field} from \"mongur\";\n\n\n@model()\nclass User extends Model<User>() {\n\n@field()\nname!: string;\n\n@field()\nemail!: string;\n\n@field()\nactive?: boolean\n\n}","insert-documents#Insert documents":"","insert-a-single-document#Insert a single document":"Single document can be inserted in 2 ways: using save method on model instance or using create class method on the model.\nconst user = new User({name: \"John Doe\", email: \"john@example.com\"})\nawait user.save()\n\n// Or use the create method.\nconst user = await User.create({name: \"John Doe\", email: \"john@example.com\"})\n\n// `create` method also accepts model instance\nconst savedUser = await User.create(user)","insert-multiple-documents#Insert multiple documents":"create class method accepts an array.\n// Returns inserted users\nconst users = await User.create([{name: \"John Doe\", email: \"john@example.com\"}, {name: \"Jane Doe\", email: \"jane@example.com\"}])\n\n// Or insert 2 object instances\nconst user1 = new User({name: \"John Doe\", email: \"john@example.com\"})\nconst user2 = new User({name: \"Jane Doe\", email: \"jane@example.com\"})\nconst users = await User.create([user1, user2])","get-documents#Get documents":"","get-multiple-documents#Get multiple documents":"Use find() to return multiple documents.\n// Get all users, returns array\nconst users = await User.find()\n\n// Get all active users, returns array\nconst users = await User.find({active: true})","limit-results#Limit results":"Use skip() and limit() to limit the number of documents returned.\n// Return 10 users, skip first 10 users\nconst users = await User.find({active: true}).skip(10).limit(10)","sort-results#Sort results":"Use sort() method to sort results.\n// Sort by name ascending, and email descending\nconst users = await User.find({active: true}).sort(\"name\", \"-email\")\n\n// Same query but use object to specify sort\nconst users = await User.find({active: true}).sort({name: 1, email: -1})","get-only-specific-fields#Get only specific fields":"Use select() to get specific fields\n// Return 10 users, skip first 10 users\nconst users = await User.find({active: true}).select(\"name\", \"email\")","get-a-single-document#Get a single document":"use one() to get a single document.\n// Get a user by email, returns one user or null\nconst user = await User.find({email: \"name@example.com\"}).one()\n\n// Get a user by email, returns one user, throws error if not exists\nconst user = await User.find({email: \"name@example.com\"}).one().orThrow()\n\nselect, skip, min, max, limit, one, sort these methods are chainable.","update-documents#Update documents":"","update-multiple-documents#Update multiple documents":"Use find() to filter out which documents to update, then use update() to update the documents.\n// Make all users active\nconst updateResult = await User.find().update({$set: {active: true}})\n\n// Make all inactive users active\nconst users = await User.find({active: false}).update({$set: {active: true}})","update-a-single-document#Update a single document":"Just like updating multiple documents but call one() at the end.\n// Update one user\nconst updateResult = await User.find({email: \"jane@example.com\"}).update({$set: {active: true}}).one()\nUpdating can be done on model instance object too.\n// Create user\nconst user = new User({name: \"John Doe\", email: \"john@example.com\"})\nawait user.save()\n\n// Now change something and save the changes\nuser.email = \"doe@example.com\"\nawait user.save() // This will only update the changed fields.\nCalling save() method on an object that was already saved, or fetched using find() automatically updates\nthe changed fields. If you want to update only specific fields, it can done by passing the field names in the save method\nawait user.save([\"email\", \"name\"]) // This will update email and name fields","update-and-fetch#Update and fetch":"Mongodb native sdk has a method called findOneAndUpdate. It returns the document when updating,\neither the document before update or the updated document based on the supplied parameter. The same can be achieved in Mongur\nusing the return() method.\n// Update one user and return the document\nconst user = await User.find({email: \"jane@example.com\"}).update({$set: {active: true}}).one().return()","delete-document#Delete document":"","delete-multiple-documents#Delete multiple documents":"Use find() to filter out which documents to delete, then use delete() to delete the documents.\n// Delete all users\nconst deleteResult = await User.find().delete()\n\n// Delete inactive users\nconst users = await User.find({active: false}).delete()","delete-a-single-document#Delete a single document":"Just like deleting multiple documents but call one() at the end.\n// Delete one user\nconst deleteResult = await User.find({email: \"jane@example.com\"}).delete().one()\nDelete operation can be done on model instance object too.\n// Create and save a user\nconst user = new User({name: \"John Doe\", email: \"john@example.com\"})\nawait user.save()\n\n// Delete it\nawait user.delete()","delete-and-fetch#Delete and fetch":"Equivalent to Mongodb native sdk's findOneAndDelete(). Call return() to return the deleted document.\n// Delete one user and return the document\nconst deletedUser = await User.find({email: \"jane@example.com\"}).delete().one().return()","replace-a-document#Replace a document":"","replace-a-single-document#Replace a single document":"Use find() to filter out which document to replace, then use replace() to replace the document.\n// Update one user\nconst newData = new User({email: \"me@example.com\", name: \"Me\"})\nconst replaceResult = await User.find({email: \"jane@example.com\"}).replace(newData).one()\nReplace operation is not available for multiple document in Mongodb. So calling one() is optional.","replace-and-fetch#Replace and fetch":"Equivalent to Mongodb native sdk's findOneAndReplace(). Call return() to return the replaced document\nor the previous document based on the supplied parameter.\n// Replace one user and return the document\nconst newData = new User({email: \"me@example.com\", name: \"Me\"})\nconst user = await User.find({email: \"jane@example.com\"}).replace(newData).one().return()","bulk-write#Bulk Write":"Equivalent to Mongodb native sdk's bulkWrite() but with a fluent API. Pass an array of BulkOp\noperations to bulkWrite() method.\nawait User.bulkWrite([\nUser.BulkOp.create(), // Insert one document,\nUser.BulkOp.create([]), // Insert multiple document,\nUser.BulkOp.find().update(), // Update multiple document\nUser.BulkOp.find().update().one(), // Update one document\nUser.BulkOp.find().replace().one(), // Replace one document\nUser.BulkOp.find().delete(), // Delete multiple document\nUser.BulkOp.find().delete().one(), // Delete one document.\n])","summary-table#Summary table":"Mongodb Nodejs Native SDK Operation\tMongur style\tinsert()\tcreate()\tinsertMany()\tcreate([])\tfindMany()\tfind()\tfindOne()\tfind().one()\tdeleteMany()\tfind().delete()\tdeleteOne()\tfind().delete().one()\tfindOneAndDelete()\tfind().delete().one().return()\tupdateMany()\tfind().update()\tupdateOne()\tfind().update().one()\tfindOneAndUpdate()\tfind().update().one().return()\treplaceOne()\tfind().replace().one()\tfindOneAndReplace()\tfind().replace().one().return()"}},"/reference/api":{"title":"API","data":{"":"","modelcreate#Model.create()":"create(docs: Array<ModelProps<T> | T>): Promise<T[]>;\ncreate(doc: ModelProps<T> | T): Promise<T>;","modelfind#Model.find()":"find(filter: Filter<T> = {}, options?: FindOptions): FindQuery<T>\n\n\n\nReturns FindQuery<T>\n\n[WIP]"}},"/reference/decorators/@field":{"title":"@field","data":{"":"[TODO]"}},"/reference/decorators/@index":{"title":"@index","data":{"":"[TODO]"}},"/reference/decorators/@model":{"title":"@model","data":{"":"Classes marked with @model decorator are schema definitions and the main point to query the database.\nfunction model<T>(options: ModelOptions): ClassDecorator","modeloptions#ModelOptions":"The decorator accepts an object with the following properties:\nexport interface ModelOptions<T> {\ncollection?: string\nindexes?: ModelIndex<T>[]\nconnection?: Connection\n}\nOptions\nName\tType\tDescription\tcollection\tstring\tBy default a collection name is generated from the class name. You can change this by providing a custom name.\tindexes\tModelIndex<T>[]\tAn array of indexes to apply on this collection. The same thing can be achieved using @index decorator. Basic indexes like unique can also be specified in the @field decorator\tconnection\tConnection\tIf this collection is in a different database, the connection object can be specified here.\n[WIP]"}}}